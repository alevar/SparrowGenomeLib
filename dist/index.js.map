{"version":3,"sources":["../src/index.ts","../src/types/types.ts","../src/types/transcriptome.ts","../src/types/plotGrid.ts","../src/utils/parsers/parsers.ts","../src/utils/utils/utils.ts","../src/utils/plots/PathogenPlot.ts","../src/utils/plots/GenomePlot.ts","../src/utils/plots/ORFPlot.ts","../src/utils/plots/TranscriptPlot.ts","../src/utils/plots/TranscriptomePlot.ts","../src/utils/plots/BarPlot.ts","../src/utils/plots/LinePlot.ts","../src/utils/plots/DataPlotArray.ts","../src/utils/plots/TriangleConnector.ts"],"sourcesContent":["export * from './types';\nexport * from './utils';","export interface BedLine {\n    seqid: string;\n    start: number;\n    end: number;\n    name: string;\n    score: number;\n    strand: string;\n}\n\nexport class BedData {\n    private data: BedLine[];\n\n    constructor() {\n        this.data = [];\n    }\n\n    public addLine(line: BedLine): void {\n        this.data.push(line);\n    }\n\n    public get length(): number {\n        return this.data.length;\n    }\n\n    public sort(): void {\n        this.data.sort((a, b) => a.start - b.start);\n    }\n\n    public numEntries(): number {\n        return this.data.length;\n    }\n\n    public maxScore(): number {\n        return Math.max(...this.data.map(d => d.score));\n    }\n\n    public getData(): BedLine[] {\n        return this.data;\n    }\n\n    public getPos(pos: number): BedLine[] {\n        return this.data.filter(d => d.start <= pos && d.end >= pos);\n    }\n\n    public getRange(start: number, end: number): BedData {\n        // construct a new BedData object consisting of the data within the range\n        let new_data = new BedData();\n        for (let i = 0; i < this.data.length; i++) {\n            let line = this.data[i];\n            if (line.start <= end && line.end > start) {\n                // trim line to the range\n                let new_line = Object.assign({}, line);\n                new_line.start = Math.max(line.start, start);\n                new_line.end = Math.min(line.end, end);\n                new_data.addLine(new_line);\n            }\n        }\n        return new_data;\n    }\n\n    public explode(): BedData {\n        // explode the data into individual lines\n        let new_data = new BedData();\n        for (let i = 0; i < this.data.length; i++) {\n            let line = this.data[i];\n            for (let j = line.start; j < line.end; j++) { // Corrected to use half-open interval\n                let new_line = { ...line }; // Use spread syntax for shallow copy\n                new_line.start = j;\n                new_line.end = j + 1; // Each exploded line represents one base\n                new_data.addLine(new_line);\n            }\n        }\n        return new_data;\n    }\n}\n\nexport interface BedFile {\n    data: BedData;\n    fileName: string;\n    status: 1 | 0 | -1; // valid | parsing | error\n}\n\nexport type Interval = [number, number];\n\nexport interface Dimensions {\n    width: number;\n    height: number;\n    x: number;\n    y: number;\n    fontSize: number;\n}","type FeatureType = 'transcript' | 'exon' | 'CDS' | 'other';\n\nclass GTFObject {\n    seqid: string;\n    strand: string;\n    type: FeatureType;\n    start: number;\n    end: number;\n    attributes: Record<string, string>;\n    transcript_id?: string;\n\n    constructor(seqid: string, strand: string, start: number, end: number, type: FeatureType, attributes: Record<string, string>, transcript_id?: string) {\n        if (start < 0 || end < 0 || start > end) {\n            throw new Error('Invalid interval');\n        }\n        this.seqid = seqid;\n        this.strand = strand;\n        this.start = start;\n        this.end = end;\n        this.type = type;\n        this.attributes = attributes;\n        this.transcript_id = transcript_id;\n    }\n\n    getAttribute(key: string): string {\n        return this.attributes[key];\n    }\n    getStart(): number {\n        return this.start;\n    }\n    getEnd(): number {\n        return this.end;\n    }\n}\n\nclass Exon extends GTFObject { }\nclass CDS extends GTFObject { }\nclass Object extends GTFObject {\n    originalType: string;\n\n    constructor(seqid: string, strand: string, start: number, end: number, type: FeatureType, attributes: Record<string, string>, originalType: string) {\n        super(seqid, strand, start, end, type, attributes);\n        this.originalType = originalType;\n    }\n}\n\nclass Transcript extends GTFObject {\n    exons: Exon[] = [];\n    cdsFeatures: CDS[] = [];\n    gene_id: string;\n\n    constructor(\n        seqid: string,\n        strand: string,\n        start: number,\n        end: number,\n        attributes: Record<string, string>,\n        transcript_id: string,\n        gene_id: string\n    ) {\n        super(seqid, strand, start, end, 'transcript', attributes, transcript_id);\n        this.gene_id = gene_id;\n    }\n\n    addExon(exon: Exon) {\n        if (exon.seqid !== this.seqid || exon.strand !== this.strand) {\n            throw new Error(`Inconsistent seqid or strand in exon ${exon.transcript_id}`);\n        }\n        if (exon.start < this.start || exon.end > this.end) {\n            throw new Error(`Exon ${exon.transcript_id} out of transcript bounds`);\n        }\n        this.exons.push(exon);\n        this.exons.sort((a, b) => a.start - b.start);\n    }\n\n    addCDS(cds: CDS) {\n        if (cds.seqid !== this.seqid || cds.strand !== this.strand) {\n            throw new Error(`Inconsistent seqid or strand in CDS ${cds.transcript_id}`);\n        }\n        if (cds.start < this.start || cds.end > this.end) {\n            throw new Error(`CDS ${cds.transcript_id} out of transcript bounds`);\n        }\n        this.cdsFeatures.push(cds);\n        this.cdsFeatures.sort((a, b) => a.start - b.start);\n    }\n\n    getCDS(): CDS[] {\n        return this.cdsFeatures;\n    }\n    getExons(): Exon[] {\n        return this.exons;\n    }\n    getTranscriptId(): string {\n        return this.transcript_id||\"\";\n    }\n}\n\nclass Transcriptome {\n    seqid?: string;\n    strand?: string;\n    start?: number;\n    end?: number;\n\n    transcripts: Transcript[] = [];\n    otherFeatures: GTFObject[] = [];\n    transcriptsByGene: Map<string, number[]> = new Map();\n    transcriptsById: Map<string, number> = new Map();\n\n    genome_length: number = 0;\n\n    constructor(gtfFile?: File) {\n        if (gtfFile) {\n            this.parseGTFFile(gtfFile);\n        }\n    }\n\n    static async create(file: File): Promise<Transcriptome> {\n        const instance = new Transcriptome();\n        await instance.parseGTFFile(file);\n        return instance;\n    }\n\n    private parseGTFFile(gtfFile: File): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = (e) => {\n                try {\n                    const result = e.target?.result as string;\n                    const lines = result.split('\\n');\n\n                    for (const line of lines) {\n                        if (line.startsWith('#') || !line.trim()) continue;\n                        const [seqid, , type, startStr, endStr, , strand, , attrStr] = line.split('\\t');\n\n                        const start = parseInt(startStr);\n                        const end = parseInt(endStr);\n                        const attributes = this.parseAttributes(attrStr);\n\n                        // make sure seqid and strand is the same for all transcriptome otherwise set to current seqid if was undefined\n                        if (this.seqid && this.seqid !== seqid) {\n                            throw new Error('Inconsistent seqid');\n                        }\n                        if (this.strand && this.strand !== strand) {\n                            throw new Error('Inconsistent strand');\n                        }\n                        this.seqid = seqid;\n                        this.strand = strand;\n                        // set start and end to the min and max of all transcriptome\n                        if (this.start === undefined || this.start > parseInt(startStr)) {\n                            this.start = parseInt(startStr);\n                        }\n                        if (this.end === undefined || this.end < parseInt(endStr)) {\n                            this.end = parseInt(endStr);\n                        }\n\n                        switch (type) {\n                            case 'transcript':\n                            case 'exon':\n                            case 'CDS':\n                                break;\n                            default:\n                                const otherObject = new Object(seqid, strand, start, end, 'other' as FeatureType, attributes, type);\n                                this.otherFeatures.push(otherObject);\n                                continue;\n                        }\n\n                        const transcript_id = attributes['transcript_id'];\n                        let tx_idx: number | undefined;\n\n                        switch (type) {\n                            case 'transcript':\n                                const gene_id = attributes['gene_id'];\n                                const transcript = new Transcript(seqid, strand, start, end, attributes, transcript_id, gene_id);\n                                this.transcripts.push(transcript);\n                                tx_idx = this.transcripts.length - 1;\n                                this.transcriptsById.set(transcript_id, tx_idx);\n                                if (!this.transcriptsByGene.has(gene_id)) {\n                                    this.transcriptsByGene.set(gene_id, []);\n                                }\n                                this.transcriptsByGene.get(gene_id)?.push(tx_idx);\n\n                                break;\n                            case 'exon':\n                                tx_idx = this.transcriptsById.get(transcript_id);\n                                if (tx_idx === undefined) {\n                                    throw new Error(`Exon references unknown transcript_id ${transcript_id}`);\n                                }\n                                const exon = new Exon(seqid, strand, start, end, 'exon', attributes, transcript_id);\n                                this.transcripts[tx_idx].addExon(exon);\n                                break;\n                            case 'CDS':\n                                tx_idx = this.transcriptsById.get(transcript_id);\n                                if (tx_idx === undefined) {\n                                    throw new Error(`CDS references unknown transcript_id ${transcript_id}`);\n                                }\n                                const cds = new CDS(seqid, strand, start, end, 'CDS', attributes, transcript_id);\n                                this.transcripts[tx_idx].addCDS(cds);\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n                    resolve();\n                } catch (error) {\n                    console.error(`Failed to parse GTF file: ${error instanceof Error ? error.message : error}`);\n                    reject(error);\n                }\n            };\n            reader.onerror = () => {\n                console.error('Failed to read the file');\n                reject(new Error('Failed to read the file'));\n            };\n            reader.readAsText(gtfFile);\n        });\n    }\n\n    private parseAttributes(attrStr: string): Record<string, string> {\n        const attributes: Record<string, string> = {};\n        attrStr.split(';').forEach(attr => {\n            const [key, value] = attr.trim().split(' ');\n            if (key && value) {\n                attributes[key] = value.replace(/\"/g, '');\n            }\n        });\n        return attributes;\n    }\n\n    getTranscriptsByGene(gene_id: string): Transcript[] | undefined {\n        const indices = this.transcriptsByGene.get(gene_id);\n        if (!indices) {\n            return undefined;\n        }\n        return indices.map(idx => this.transcripts[idx]);\n    }\n\n    getTranscriptById(transcript_id: string): Transcript | undefined {\n        const idx = this.transcriptsById.get(transcript_id);\n        if (idx === undefined) {\n            return undefined;\n        }\n        return this.transcripts[idx];\n    }\n\n    getStart(): number {\n        return this.start || 0;\n    }\n    getEnd(): number {\n        return this.end || 0;\n    }\n    // iterator over transcripts\n    [Symbol.iterator]() {\n        let index = 0;\n        const transcripts = this.transcripts;\n        return {\n            next(): { value: Transcript, done: boolean; } {\n                if (index < transcripts.length) {\n                    return { value: transcripts[index++], done: false };\n                } else {\n                    return { value: transcripts[index++], done: true };\n                }\n            }\n        };\n    }\n\n    // iterator by gene. yields gene_id and a list of associated transcripts\n    *genes(): Generator<[string, Transcript[]], void, unknown> {\n        for (const [gene_id, tx_indices] of this.transcriptsByGene) {\n            const transcripts: Transcript[] = tx_indices.map(idx => this.transcripts[idx]);\n            yield [gene_id, transcripts];\n        }\n    }\n\n    numTranscripts(): number {\n        return this.transcripts.length;\n    }\n\n    // iterator over splice junctions\n    *junctions(): Generator<[number, number], void, unknown> {\n        const seen_junctions = new Set<number[]>();\n        for (const transcript of this.transcripts) {\n            const exons = transcript.getExons();\n            for (let i = 0; i < exons.length - 1; i++) {\n                const junction = [exons[i].end,exons[i + 1].start];\n                if (!seen_junctions.has(junction)) {\n                    seen_junctions.add(junction);\n                    yield [junction[0], junction[1]];\n                }\n            }\n        }\n    }\n    *donors(): Generator<number, void, unknown> {\n        const seen_donors = new Set<number>();\n        for (const [donor, ] of this.junctions()) {\n            if (!seen_donors.has(donor)) {\n                seen_donors.add(donor);\n                yield donor;\n            }\n        }\n    }\n    *acceptors(): Generator<number, void, unknown> {\n        const seen_acceptors = new Set<number>();\n        for (const [, acceptor] of this.junctions()) {\n            if (!seen_acceptors.has(acceptor)) {\n                seen_acceptors.add(acceptor);\n                yield acceptor;\n            }\n        }\n    }\n}\n\nexport { Transcriptome, Transcript, Exon, CDS };","export interface GridConfig {\n    columns: number;\n    columnRatios: number[];\n    rowRatiosPerColumn: number[][];\n}\n\nexport interface Padding {\n    top: number;\n    bottom: number;\n    left: number;\n    right: number;\n}\n\nexport class D3Grid {\n    private height: number;\n    private width: number;\n    private gridConfig: GridConfig;\n    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    private cellDimensions_raw: { width: number, height: number }[][];\n    private cellDimensions: { width: number, height: number }[][];\n    private cellCoordinates: { x: number, y: number }[][];\n    private cellData: any[][]; // holds any data associated with each cell\n    private cellSvgs: d3.Selection<SVGSVGElement, unknown, null, undefined>[][];\n\n    constructor(\n        svg: d3.Selection<SVGSVGElement, unknown, null, undefined>, \n        height: number, \n        width: number, \n        gridConfig: GridConfig\n    ) {\n        this.height = height;\n        this.width = width;\n        this.gridConfig = gridConfig;\n\n        this.cellDimensions_raw = [];\n        this.cellDimensions = [];\n        this.cellCoordinates = [];\n        this.cellData = [];\n        this.cellSvgs = [];\n        this.svg = svg\n            .attr('width', this.width)\n            .attr('height', this.height);\n\n        // Setup grid\n        this.setupGrid();\n    }\n\n    private setupGrid(): void {\n        const totalColumnRatio = this.gridConfig.columnRatios.reduce((sum, ratio) => sum + ratio, 0);\n\n        let xOffset = 0;\n        this.gridConfig.columnRatios.forEach((colRatio, colIndex) => {\n            const columnWidth = (colRatio / totalColumnRatio) * this.width;\n            const totalRowRatio = this.gridConfig.rowRatiosPerColumn[colIndex].reduce((sum, ratio) => sum + ratio, 0);\n            this.cellDimensions_raw[colIndex] = [];\n            this.cellDimensions[colIndex] = [];\n            this.cellCoordinates[colIndex] = [];\n            this.cellData[colIndex] = [];\n            this.cellSvgs[colIndex] = [];\n\n            let yOffset = 0;\n            this.gridConfig.rowRatiosPerColumn[colIndex].forEach((rowRatio, rowIndex) => {\n                const rowHeight = (rowRatio / totalRowRatio) * this.height;\n\n                const paddedWidth = columnWidth;\n                const paddedHeight = rowHeight;\n\n                this.cellDimensions_raw[colIndex][rowIndex] = { width: columnWidth, height: rowHeight };\n                this.cellDimensions[colIndex][rowIndex] = { width: paddedWidth, height: paddedHeight };\n                this.cellCoordinates[colIndex][rowIndex] = { x: xOffset, y: yOffset };\n                this.cellData[colIndex][rowIndex] = {};\n\n                const new_svg = this.svg.append('svg')\n                    .attr('x', xOffset)\n                    .attr('y', yOffset)\n                    .attr('width', columnWidth)\n                    .attr('height', rowHeight);\n                this.cellSvgs[colIndex][rowIndex] = new_svg;\n\n                yOffset += rowHeight;\n            });\n\n            xOffset += columnWidth;\n        });\n    }\n\n    public getCellData(colIndex: number, rowIndex: number): any {\n        return this.cellData[colIndex]?.[rowIndex];\n    }\n\n    public setCellData(colIndex: number, rowIndex: number, data: any): void {\n        this.cellData[colIndex][rowIndex] = data;\n    }\n\n    public getSvg(): d3.Selection<SVGSVGElement, unknown, null, undefined> {\n        return this.svg;\n    }\n\n    public getCellDimensions(colIndex: number, rowIndex: number): { width: number, height: number } | undefined {\n        return this.cellDimensions[colIndex]?.[rowIndex];\n    }\n\n    public getCellCoordinates_unpadded(colIndex: number, rowIndex: number): { x: number, y: number } | undefined {\n        return this.cellCoordinates[colIndex]?.[rowIndex];\n    }\n\n    public getCellCoordinates(colIndex: number, rowIndex: number): { x: number, y: number } | undefined {\n        const coordinates = this.cellCoordinates[colIndex]?.[rowIndex];\n        if (coordinates) {\n            return {\n                x: coordinates.x,\n                y: coordinates.y\n            };\n        }\n        return undefined;\n    }\n\n    public getCellSvg(colIndex: number, rowIndex: number): d3.Selection<SVGSVGElement, unknown, null, undefined> | undefined {\n        return this.cellSvgs[colIndex]?.[rowIndex];\n    }\n\n    public createOverlaySvg(colIndex: number, rowIndices: number[]): d3.Selection<SVGSVGElement, unknown, null, undefined> {\n        // Determine the combined height and position based on the rows to be combined\n        const combinedHeight = rowIndices.reduce((sum, rowIndex) => sum + this.cellDimensions_raw[colIndex][rowIndex].height, 0);\n        const firstRowIndex = rowIndices[0];\n        const firstCellCoords = this.getCellCoordinates_unpadded(colIndex, firstRowIndex);\n    \n        const combinedWidth = this.cellDimensions[colIndex][firstRowIndex].width;\n    \n        // Create a new SVG for the overlay\n        const overlaySvg = this.svg.append('svg')\n            .attr('x', firstCellCoords?.x || 0) // Use 0 as default if x is undefined\n            .attr('y', firstCellCoords?.y || 0) // Use 0 as default if y is undefined\n            .attr('width', combinedWidth)\n            .attr('height', combinedHeight)\n            .style('pointer-events', 'none'); // Make sure the overlay doesn't block interactions with underlying SVGs\n    \n        return overlaySvg;\n    }\n\n    public promote(colIndex: number, rowIndex: number): void {\n        const cellSvg = this.getCellSvg(colIndex, rowIndex);\n        if (cellSvg) {\n            cellSvg.raise();\n        }\n    }\n}","import { BedFile, BedData, BedLine } from '../../types';\n\nexport function parseBed(bedFileName: File): Promise<BedFile> {\n    return new Promise((resolve, reject) => {\n        const bedFile: BedFile = {\n            data: new BedData(),\n            fileName: bedFileName.name,\n            status: 1,\n        };\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            try {\n                const result = e.target?.result as string;\n                const lines = result.split('\\n');\n                lines.forEach((line) => {\n                    // skip empty lines\n                    if (line.trim() === '') {\n                        return;\n                    }\n                    const fields = line.split('\\t');\n                    if (fields.length === 6) {\n                        const [seqid, start, end, name, score, strand] = fields;\n                        const bedLine: BedLine = {\n                            seqid: seqid,\n                            start: parseInt(start),\n                            end: parseInt(end),\n                            name: name,\n                            score: parseFloat(score),\n                            strand: strand,\n                        };\n                        bedFile.data.addLine(bedLine);\n                    } else {\n                        throw new Error(`Invalid line format: ${line}`);\n                    }\n                });\n                resolve(bedFile);\n            } catch (error) {\n                reject(new Error('Failed to parse BED file'));\n            }\n        };\n        reader.onerror = () => {\n            reject(new Error('Failed to read the file'));\n        };\n        reader.readAsText(bedFileName);\n    });\n}","import { Interval } from '../../types';\n\nexport function adjustIntervals(intervals: Interval[], start: number, end: number, separator: number): Interval[] {\n    if (intervals.length <= 1) {\n        return intervals;\n    }\n\n    // Sort intervals by their start position\n    intervals.sort((a, b) => a[0] - b[0]);\n\n    const totalIntervals = intervals.length;\n    const totalSpace = end - start;\n    const totalIntervalWidth = intervals.reduce((acc, interval) => acc + ((interval[1] - interval[0]) + separator), 0); // separator is added here to account for the space between intervals\n    const emptyScaleFactor = (totalSpace - totalIntervalWidth) / totalSpace; // total fraction of space that is not occupied by intervals\n\n    // compute intervals between interval median points\n    let negativeIntervals = [[0,0]];\n    for (let i = 0; i < totalIntervals; i++) {\n        const midpoint = computeMidpoint(intervals[i][0], intervals[i][1]);\n        negativeIntervals[negativeIntervals.length - 1][1] = midpoint;\n        negativeIntervals.push([midpoint,end]);\n    }\n\n    // compute scaled width of spacers\n    let scaledSpacerWidths = [];\n    for (let i = 0; i < negativeIntervals.length; i++) {\n        const interval = negativeIntervals[i];\n        const intervalWidth = (interval[1] - interval[0])-separator;\n        const scaledWidth = intervalWidth * emptyScaleFactor;\n        scaledSpacerWidths.push(scaledWidth);\n    }\n\n    // compute positions of original intervals separated by scaled spacers\n    let new_intervals: Interval[] = [];\n    let prev_end = start;\n    for (let i = 0; i < totalIntervals; i++) {\n        const interval = intervals[i];\n        const intervalWidth = (interval[1] - interval[0]);\n        const spacer = scaledSpacerWidths[i]+separator;\n        const new_interval: Interval = [prev_end+spacer, prev_end + spacer + intervalWidth];\n        prev_end = new_interval[1];\n        new_intervals.push(new_interval);\n    }\n    \n    return new_intervals;\n}\n\n\nexport function computeMidpoint(a: number, b: number): number {\n    // Ensure a is less than b\n    if (a > b) {\n        [a, b] = [b, a];\n    }\n\n    // Calculate the midpoint\n    const midpoint = (a + b) / 2;\n\n    return midpoint;\n}","import { ORFPlot } from \".\";\nimport { Transcriptome, Dimensions, D3Grid, GridConfig } from \"../../types\";\n\ninterface PathogenPlotData {\n    transcriptome: Transcriptome;\n    dimensions: Dimensions;\n}\n\nexport class PathogenPlot {\n    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    private dimensions: Dimensions;\n    private transcriptome: Transcriptome;\n\n    private gridConfig: GridConfig = {\n        columns: 1,\n        columnRatios: [1],\n        rowRatiosPerColumn: [\n            [0.0, 1], // genomePlot, ORFPlot\n        ]\n    };\n    private grid: D3Grid;\n\n    constructor(svgElement: d3.Selection<SVGSVGElement, unknown, null, undefined>,\n        data: PathogenPlotData) {\n        this.svg = svgElement;\n        this.dimensions = data.dimensions;\n        this.transcriptome = data.transcriptome;\n\n        this.grid = new D3Grid(this.svg, this.dimensions.height, this.dimensions.width, this.gridConfig);\n    }\n\n    public plot(): void {\n\n        const orfPlotSvg = this.grid.getCellSvg(0, 1);\n        if (orfPlotSvg) {\n            const svg_dimensions = this.grid.getCellDimensions(0, 1);\n            const svg_coordinates = this.grid.getCellCoordinates(0, 1);\n\n            const orfPlotDimensions = {\n                width: svg_dimensions?.width || 0,\n                height: svg_dimensions?.height || 0,\n                x: svg_coordinates?.x || 0,\n                y: svg_coordinates?.y || 0,\n                fontSize: this.dimensions.fontSize,\n            };\n\n            const orfPlot = new ORFPlot(this.svg, {\n                dimensions: orfPlotDimensions, \n                transcriptome: this.transcriptome\n            });\n            orfPlot.plot();\n        }\n    }\n}","export class GenomePlot {\n    private svg: d3.Selection<SVGSVGElement, unknown, HTMLElement, any>;\n    private dimensions: any;\n    private genome_length: number;\n    private gtf_data: any;\n\n    constructor(svg: d3.Selection<SVGSVGElement, unknown, HTMLElement, any>, dimensions: any, genome_length: number, gtf_data: any) {\n        this.svg = svg;\n        this.dimensions = dimensions;\n        this.genome_length = genome_length;\n        this.gtf_data = gtf_data;\n    }\n\n    public plot(): void {\n        this.svg.append('rect')\n            .attr('x', 0)\n            .attr('y', this.dimensions[\"y\"])\n            .attr('width', this.dimensions[\"width\"])\n            .attr('height', this.dimensions[\"height\"])\n            .attr('rx', this.dimensions[\"height\"] / 2)\n            .attr('ry', this.dimensions[\"height\"] / 2)\n            .style('fill', '#dddddd');\n\n        for (const component of this.gtf_data[\"genome_components\"]) {\n            if (component[\"type\"] === \"ltr\") {\n                this.svg.append('rect')\n                    .attr('x', (component[\"position\"][0] / this.genome_length) * this.dimensions[\"width\"])\n                    .attr('y', this.dimensions[\"y\"])\n                    .attr('width', ((component[\"position\"][1] - component[\"position\"][0]) / this.genome_length) * this.dimensions[\"width\"])\n                    .attr('height', this.dimensions[\"height\"])\n                    .attr('rx', this.dimensions[\"height\"] / 2)\n                    .attr('ry', this.dimensions[\"height\"] / 2)\n                    .style('fill', '#3652AD');\n            }\n        }\n        for (const component of this.gtf_data[\"genome_components\"]) {\n            if (component[\"type\"] === \"ltr\") {\n                // add text label to the middle of the rectangle\n                this.svg.append('text')\n                    .attr('x', (component[\"position\"][0] / this.genome_length) * this.dimensions[\"width\"] + (((component[\"position\"][1] - component[\"position\"][0]) / this.genome_length) * this.dimensions[\"width\"]) / 2)\n                    .attr('y', (this.dimensions[\"y\"]) + (this.dimensions[\"height\"] / 1.25))\n                    .attr('text-anchor', 'middle')\n                    .style('fill', 'white')\n                    .style('font-size', this.dimensions[\"font_size\"] + \"px\")\n                    .text(component[\"name\"]);\n            }\n        }\n    }\n}","import { Transcriptome, Dimensions } from '../../types';\n\ninterface ORFPlotData {\n    transcriptome: Transcriptome;\n    dimensions: Dimensions;\n}\n\nexport class ORFPlot {\n    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    private dimensions: Dimensions;\n    private transcriptome: Transcriptome;\n\n    constructor(svg: d3.Selection<SVGSVGElement, unknown, null, undefined>,\n        data: ORFPlotData\n    ) {\n        this.svg = svg;\n        this.dimensions = data.dimensions;\n        this.transcriptome = data.transcriptome;\n    }\n\n    public plot(): void {\n        const unique_orfs = new Set();\n        const orfs = [];\n\n        for (const transcript of this.transcriptome) {\n            if (transcript.getCDS().length === 0) {\n                continue;\n            }\n            const CDSs = transcript.getCDS();\n            const cds_chain = CDSs.map(obj => ([obj.getStart(), obj.getEnd() ]));\n            const cds_string = cds_chain.toString();\n            if (!unique_orfs.has(cds_string)) {\n                unique_orfs.add(cds_string);\n                orfs.push({ 'orf': transcript.getCDS(), 'gene_name': transcript.getAttribute('gene_name'), 'y': 0 });\n            }\n        }\n        orfs.sort((a, b) => a[\"orf\"][0].getStart() - b[\"orf\"][0].getStart());\n\n        let rows: number[] = [];\n        for (const orf of orfs) {\n            let found_row = false;\n            let row_i = 0;\n            for (const row of rows) {\n                if (orf[\"orf\"][0].getStart() > row) {\n                    found_row = true;\n                    rows[row_i] = orf[\"orf\"][orf[\"orf\"].length-1].getEnd();\n                    orf[\"y\"] = row_i;\n                    break;\n                }\n                row_i += 1;\n            }\n            if (!found_row) {\n                rows.push(orf[\"orf\"][orf[\"orf\"].length-1].getEnd());\n                orf[\"y\"] = rows.length - 1;\n            }\n        }\n\n        const orf_height = (this.dimensions[\"height\"] / rows.length) * 0.8;\n        const offset = this.dimensions[\"height\"] / rows.length;\n\n        for (const orf of orfs) {\n            for (let c_i = 0; c_i < orf[\"orf\"].length; c_i++) {\n                const cds = orf[\"orf\"][c_i];\n                const cds_start = (cds.getStart() / this.transcriptome.getEnd()) * this.dimensions[\"width\"];\n                const cds_end = (cds.getEnd() / this.transcriptome.getEnd()) * this.dimensions[\"width\"];\n                const orf_y = this.dimensions[\"y\"] + orf[\"y\"] * offset;\n\n                const orfSvg = this.svg.append('g');\n                let cur_seg = orfSvg.append('rect')\n                    .attr('x', cds_start)\n                    .attr('y', orf_y)\n                    .attr('height', orf_height)\n                    .style('fill', '#F2C14E');\n\n                if (c_i === orf[\"orf\"].length - 1) {\n                    cur_seg.attr('width', (cds_end - cds_start) - 10);\n                    const trianglePoints = `${cds_end - 10},${orf_y + orf_height} ${cds_end - 10},${orf_y} ${cds_end},${orf_y + orf_height / 2}`;\n                    orfSvg.append('polygon')\n                        .attr('points', trianglePoints)\n                        .style('fill', '#F2C14E');\n                } else {\n                    cur_seg.attr('width', (cds_end - cds_start));\n                }\n\n                if (c_i > 0) {\n                    const prev_cds_end = (orf[\"orf\"][c_i - 1].getEnd() / this.transcriptome.getEnd()) * this.dimensions[\"width\"];\n                    orfSvg.append('line')\n                        .attr('x1', prev_cds_end)\n                        .attr('y1', orf_y + orf_height / 2)\n                        .attr('x2', cds_start)\n                        .attr('y2', orf_y + orf_height / 2)\n                        .style('stroke', '#280274')\n                        .style('stroke-width', 1);\n                }\n            }\n\n            const orf_midpoint = (orf[\"orf\"][0].getStart() + orf[\"orf\"][orf[\"orf\"].length-1].getEnd()) / 2;\n            const orf_label_x = (orf_midpoint / this.transcriptome.getEnd()) * this.dimensions[\"width\"];\n            this.svg.append('text')\n                .attr('x', orf_label_x)\n                .attr('y', this.dimensions[\"y\"] + orf[\"y\"] * offset + orf_height / 2)\n                .attr('text-anchor', 'middle')\n                .style('fill', 'black')\n                .style('font-size', this.dimensions[\"fontSize\"] + \"px\")\n                .text(orf[\"gene_name\"]);\n        }\n    }\n}","import { Dimensions, Transcript } from '../../types';\n\n// displays a single transcript\n\ninterface TranscriptPlotData {\n    dimensions: Dimensions;\n    transcript: Transcript;\n    genome_length: number;\n}\n\nexport class TranscriptPlot {\n    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    private dimensions: Dimensions;\n    private genome_length: number;\n    private transcript: Transcript;\n    private exon_svgs: any;\n    private cds_svgs: any;\n    private intron_svgs: any;\n\n    constructor(svg: d3.Selection<SVGSVGElement, unknown, null, undefined>,\n        data: TranscriptPlotData) {\n        this.svg = svg;\n        this.dimensions = data.dimensions;\n        this.genome_length = data.genome_length;\n        this.transcript = data.transcript;\n        \n        this.exon_svgs = [];\n        this.cds_svgs = [];\n        this.intron_svgs = [];\n    }\n\n    public plot(): void {\n        let e_i = 0;\n        const exons = this.transcript.getExons();\n        for (const exon of exons) {\n            const exon_start = (exon.getStart() / this.genome_length) * this.dimensions[\"width\"];\n            const exon_end = (exon.getEnd() / this.genome_length) * this.dimensions[\"width\"];\n\n            const exonSvg = this.svg\n                .append('rect')\n                .attr('x', exon_start)\n                .attr('y', this.dimensions[\"height\"] * ((1 - 0.5) / 2))\n                .attr('width', (exon_end - exon_start))\n                .attr('height', this.dimensions[\"height\"] * 0.5)\n                .style('fill', '#4A88CA');\n            this.exon_svgs.push(exonSvg);\n\n            // Draw introns\n            if (e_i > 0) {\n                const prev_exon_end = (exons[e_i - 1].getEnd() / this.genome_length) * this.dimensions[\"width\"];\n                const intronSvg = this.svg.append('line')\n                    .attr('x1', prev_exon_end)\n                    .attr('y1', this.dimensions[\"height\"] / 2) // Adjust y position as needed\n                    .attr('x2', exon_start)\n                    .attr('y2', this.dimensions[\"height\"] / 2) // Adjust y position as needed\n                    .style('stroke', '#280274') // Adjust line color for gene labels\n                    .style('stroke-width', 1);\n                this.intron_svgs.push(intronSvg);\n            }\n            e_i += 1; // increment index            \n        }\n\n        // plot CDS\n        const CDSs = this.transcript.getCDS();\n        for (const cds of CDSs) {\n            // scale exon to the dimensions of the plot\n            const cds_start = (cds.getStart() / this.genome_length) * this.dimensions[\"width\"];\n            const cds_end = (cds.getEnd() / this.genome_length) * this.dimensions[\"width\"];\n            const cdsSvg = this.svg\n                .append('rect')\n                .attr('x', cds_start)\n                .attr('y', this.dimensions[\"height\"] * ((1 - 0.75) / 2))\n                .attr('width', (cds_end - cds_start))\n                .attr('height', this.dimensions[\"height\"] * 0.75)\n                .style('fill', '#F2C14E');\n            this.cds_svgs.push(cdsSvg);\n        };\n    }\n}","import { TranscriptPlot } from './TranscriptPlot';\nimport { Transcriptome, Dimensions, D3Grid, GridConfig } from '../../types';\n\n// builds a panel of all transcripts to be plotted\n\ninterface TranscriptomePlotData {\n    transcriptome: Transcriptome;\n    dimensions: Dimensions;\n}\n\nexport class TranscriptomePlot {\n    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    private dimensions: Dimensions;\n    private transcriptome: Transcriptome;\n\n    private transcript_height: number = 0;\n\n    private genes: any[] = []; // gene groups mapping gene name to upper and lower y coordinates in the plot\n\n    private gridConfig: GridConfig = {\n        columns: 1,\n        columnRatios: [1],\n        rowRatiosPerColumn: [\n            [],\n        ],\n    };\n    private grid: D3Grid;\n\n    constructor(svgElement: d3.Selection<SVGSVGElement, unknown, null, undefined>,\n        data: TranscriptomePlotData) {\n        this.svg = svgElement;\n        this.dimensions = data.dimensions;\n        this.transcriptome = data.transcriptome;\n        this.transcript_height = this.dimensions.height / this.transcriptome.numTranscripts();\n        this.genes = [];\n\n        // construct grid\n        const transcript_ratio = 1 / this.transcriptome.numTranscripts();\n        for (const _ of this.transcriptome) {\n            // add row for each transcript\n            this.gridConfig.rowRatiosPerColumn[0].push(transcript_ratio);\n        }\n\n        this.grid = new D3Grid(this.svg, this.dimensions.height, this.dimensions.width, this.gridConfig);\n    }\n\n    public plot(): any[] {\n        let tx_idx = 0;\n        for (const [gene_id, transcripts] of this.transcriptome.genes()) {\n            // pull coordinates of first transcript in the group\n            const svg_coordinates = this.grid.getCellCoordinates(0, tx_idx);\n            const y_pos = svg_coordinates?.y || 0;\n            this.genes.push({ \"name\": gene_id, \"y\": [y_pos, y_pos + transcripts.length * this.transcript_height] });\n            for (const transcript of transcripts) {\n                const txPlotSvg = this.grid.getCellSvg(0, tx_idx);\n\n                if (txPlotSvg) {\n                    const svg_dimensions = this.grid.getCellDimensions(0, tx_idx);\n                    const svg_coordinates = this.grid.getCellCoordinates(0, tx_idx);\n\n                    const txPlotDimensions = {\n                        width: svg_dimensions?.width || 0,\n                        height: svg_dimensions?.height || 0,\n                        x: svg_coordinates?.x || 0,\n                        y: svg_coordinates?.y || 0,\n                        fontSize: this.dimensions.fontSize,\n                    };\n\n                    const txPlot = new TranscriptPlot(txPlotSvg, {\n                        dimensions: txPlotDimensions,\n                        genome_length: this.transcriptome.getEnd(),\n                        transcript: transcript\n                    });\n                    txPlot.plot();\n                }\n                tx_idx += 1;\n            }\n        }\n        console.log(this.genes);\n        return this.genes;\n    }\n}\n\n\ninterface TranscriptomePlotLabelsData {\n    dimensions: Dimensions;\n    genes: any[];\n}\n\nexport class TranscriptomePlotLabels {\n    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    private dimensions: Dimensions;\n    private genes: any[];\n\n    constructor(svg: d3.Selection<SVGSVGElement, unknown, null, undefined>, \n        data: TranscriptomePlotLabelsData,\n    ) {\n        this.svg = svg;\n        this.dimensions = data.dimensions;\n        this.genes = data.genes;\n    }\n\n    private createCurlyBracePath(y0: number, y1: number): string {\n        const braceWidth = this.dimensions[\"width\"] / 4;\n        const height = y1 - y0;\n    \n        // Scale the sample path to fit the desired height\n        const scaledPath = `\n            M 0,${y0}\n            C ${braceWidth/2},${y0} 0,${y0 + height / 2} ${braceWidth},${y0 + height / 2}\n            C 0,${y0 + height / 2} ${braceWidth/2},${y1} 0,${y1}\n            \n        `;\n        \n        return scaledPath;\n    }\n\n    public plot(): void {\n        this.genes.forEach(gene => {\n            const gene_y = gene[\"y\"][0] + (gene[\"y\"][1] - gene[\"y\"][0]) / 2;\n            this.svg.append('text')\n                .attr('x', this.dimensions[\"width\"] / 2)\n                .attr('y', gene_y)\n                .attr('text-anchor', 'middle')\n                .style('fill', 'black')\n                .style('font-size', this.dimensions[\"fontSize\"] + \"px\")\n                .text(gene[\"name\"]);\n            // draw brace\n            this.svg.append('path')\n                .attr('d', this.createCurlyBracePath(gene[\"y\"][0], gene[\"y\"][1]))\n                .attr('stroke', 'black')\n                .attr('fill', 'none');\n        });\n    }\n}","import * as d3 from \"d3\";\n\nimport { Dimensions, BedData } from '../../types';\n\ninterface BarPlotData {\n    dimensions: Dimensions;\n    xScale: d3.ScaleLinear<number, number>;\n    bedData: BedData;\n    color: string;\n    yScale?: d3.ScaleLinear<number, number>; // Optional yScale parameter\n}\n\nexport class BarPlot {\n    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    private dimensions: Dimensions;\n    private bedData: BedData;\n    private xScale: d3.ScaleLinear<number, number>;\n    private yScale: d3.ScaleLinear<number, number>;\n    private useProvidedYScale: boolean = false;\n    private color: string;\n\n    constructor(\n        svg: d3.Selection<SVGSVGElement, unknown, null, undefined>,\n        data: BarPlotData) {\n        this.svg = svg;\n        this.dimensions = data.dimensions;\n        this.bedData = data.bedData;\n        this.xScale = data.xScale;\n        this.color = data.color;\n\n        this.yScale = data.yScale ?? d3.scaleLinear();\n        this.useProvidedYScale = data.yScale !== undefined;\n    }\n\n    public get_yScale(): d3.ScaleLinear<number, number> {\n        return this.yScale;\n    }\n\n    public plot(): void {\n\n        // Create the y-axis scale\n        if (!this.useProvidedYScale) {\n            this.yScale = d3.scaleLinear()\n                .domain([0, this.bedData.maxScore()])\n                .range([0,this.dimensions.height]);\n        }\n\n        // Add a background rectangle for the grid\n        this.svg.append(\"rect\")\n            .attr(\"class\", \"grid-background\")\n            .attr(\"x\", 0)\n            .attr(\"y\", 0)\n            .attr(\"width\", this.dimensions.width)\n            .attr(\"height\", this.dimensions.height)\n            .attr(\"fill\", \"#f7f7f7\")\n            .attr(\"fill-opacity\", 0.75);\n\n        // Add horizontal grid lines\n        this.svg.append(\"g\")\n            .attr(\"class\", \"grid\")\n            .attr(\"stroke\", \"rgba(0, 0, 0, 0.1)\")\n            .attr(\"stroke-width\", 1)\n            .attr(\"stroke-dasharray\", \"5,5\")\n            .attr(\"opacity\", 0.3)\n            .call(d3.axisLeft(this.yScale)\n                .ticks(2)\n                .tickSize(-this.dimensions.width)\n                .tickFormat(null));\n\n        const minBarWidth = 5;\n        this.svg.selectAll(\".bar\")\n            .data(this.bedData.getData())\n            .enter()\n            .append(\"rect\")\n            .attr(\"class\", \"bar\")\n            .attr(\"x\", d => this.xScale(d.start)) // Position the bar based on start\n            .attr(\"y\", d => this.yScale(d.score)) // Position the top of the bar based on score\n            .attr(\"width\", d => Math.min(this.xScale(d.end) - this.xScale(d.start), minBarWidth)) // Width is based on start to end\n            .attr(\"height\", d => this.dimensions.y + this.dimensions.height - this.yScale(d.score)) // Height based on score\n            .attr(\"fill\", this.color);\n    }\n}","import * as d3 from \"d3\";\nimport { Dimensions, BedData } from '../../types';\n\ninterface LinePlotData {\n    dimensions: Dimensions;\n    bedData: BedData;\n    color: string;\n    xScale: d3.ScaleLinear<number, number>;\n    yScale?: d3.ScaleLinear<number, number>; // Optional yScale parameter\n}\n\nexport class LinePlot {\n    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    private dimensions: Dimensions;\n    private bedData: BedData;\n    private xScale: d3.ScaleLinear<number, number>;\n    private yScale: d3.ScaleLinear<number, number>;\n    private useProvidedYScale: boolean = false;\n    private color: string;\n\n    constructor(\n        svg: d3.Selection<SVGSVGElement, unknown, null, undefined>,\n        data: LinePlotData\n    ) {\n        this.svg = svg;\n        this.dimensions = data.dimensions;\n        this.bedData = data.bedData;\n        this.xScale = data.xScale;\n        this.color = data.color;\n\n        // Use provided yScale if available, otherwise initialize a new scale\n        this.yScale = data.yScale ?? d3.scaleLinear();\n        this.useProvidedYScale = data.yScale !== undefined;\n    }\n\n    public get_yScale(): d3.ScaleLinear<number, number> {\n        return this.yScale;\n    }\n\n    public plot(): void {\n\n        // Check if yScale is already set (provided externally). If not, set it based on bedData.\n        if (!this.useProvidedYScale) {\n            this.yScale = d3.scaleLinear()\n                .domain([0, this.bedData.maxScore()])\n                .range([this.dimensions.height, 0]); // Reverse range if needed for correct orientation\n        }\n\n        // Add a background rectangle for the grid\n        this.svg.append(\"rect\")\n            .attr(\"class\", \"grid-background\")\n            .attr(\"x\", 0)\n            .attr(\"y\", 0)\n            .attr(\"width\", this.dimensions.width)\n            .attr(\"height\", this.dimensions.height)\n            .attr(\"fill\", \"#f7f7f7\")\n            .attr(\"fill-opacity\", 0.75);\n\n        // Add horizontal grid lines\n        this.svg.append(\"g\")\n            .attr(\"class\", \"grid\")\n            .attr(\"stroke\", \"rgba(0, 0, 0, 0.1)\")\n            .attr(\"stroke-width\", 1)\n            .attr(\"stroke-dasharray\", \"5,5\")\n            .attr(\"opacity\", 0.3)\n            .call(d3.axisLeft(this.yScale)\n                .ticks(2)\n                .tickSize(-this.dimensions.width)\n                .tickFormat(null)\n            );\n\n        // Prepare data points for the line plot\n        const lineData = this.bedData.getData().flatMap(d => {\n            const points = [];\n            console.log(d);\n            for (let pos = d.start; pos < d.end; pos++) {\n                console.log(\"x: \", pos, this.xScale(pos), \"y: \", d.score, this.yScale(d.score));\n                points.push({ x: this.xScale(pos), y: this.yScale(d.score) });\n            }\n            return points;\n        });\n\n        // Define the line generator\n        const lineGenerator = d3.line<{ x: number, y: number }>()\n            .x(d => d.x)\n            .y(d => d.y)\n            .curve(d3.curveMonotoneX); // Smooth the line\n\n        // Draw the line path\n        this.svg.append(\"path\")\n            .datum(lineData)\n            .attr(\"class\", \"line\")\n            .attr(\"d\", lineGenerator)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", this.color)\n            .attr(\"stroke-width\", 2);\n\n        // Draw circles at each data point\n        this.svg.selectAll(\".point\")\n            .data(lineData)\n            .enter()\n            .append(\"circle\")\n            .attr(\"class\", \"point\")\n            .attr(\"cx\", d => d.x)\n            .attr(\"cy\", d => d.y)\n            .attr(\"r\", 3)\n            .attr(\"fill\", this.color);\n    }\n}\n","import * as d3 from 'd3';\n\nimport { Dimensions, D3Grid, GridConfig, Interval } from '../../types';\nimport { adjustIntervals } from '../utils';\n\ninterface DataPlotArrayData {\n    svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    dimensions: Dimensions;\n    elements: number[];\n    elementWidth: number;\n    coordinateLength: number,\n    maxValue: number;\n}\n\n// sets up a grid for displaying multiple data plots\n// keeps consistent scale across all plots\n// provides a mapping of coordinates to x-axis positions on the global grid\n// provides interface for insertind data plots into the grid\nexport class DataPlotArray {\n    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    private dimensions: Dimensions;\n    private elements: number[];\n    private elementWidth: number;\n    private coordinateLength: number;\n    private maxValue: number;\n\n    private yScale: d3.ScaleLinear<number, number>;\n\n    private raw_xs: Interval[]; // positions of the elements before spreading\n    private spread_elements: Interval[]; // positions of the elements on the transformed grid\n    private element_indices: number[]; // indices of the elements in the grid\n\n    private gridConfig: GridConfig = {\n        columns: 0,\n        columnRatios: [],\n        rowRatiosPerColumn: [],\n    };\n    private grid: D3Grid;\n\n    constructor(\n        data: DataPlotArrayData) {\n        this.svg = data.svg;\n        this.dimensions = data.dimensions;\n        this.elements = data.elements;\n        this.elementWidth = data.elementWidth;\n        this.coordinateLength = data.coordinateLength;\n        this.maxValue = data.maxValue;\n\n        this.yScale = d3.scaleLinear();\n\n        // compute mapping of x-axis positions to the grid\n        this.raw_xs = [];\n        this.spread_elements = [];\n        this.build_xs();\n        \n        // setup the grid based on the coordinates\n        this.element_indices = [];\n        this.gridConfig = {\n            columns: 0,\n            columnRatios: [] as number[],\n            rowRatiosPerColumn: [\n            ],\n        }\n        this.grid = this.build_grid();\n    }\n\n    private build_xs(): void {\n        let spread_xs: any = [];\n\n        this.elements.forEach(elem => {\n            const percent_position = (elem / this.coordinateLength) * this.dimensions[\"width\"];\n            const interval_start = percent_position - this.elementWidth / 2;\n            const interval_end = percent_position + this.elementWidth / 2;\n            this.raw_xs.push([interval_start, interval_end]);\n            spread_xs.push([interval_start, interval_end]);\n        });\n\n        this.spread_elements = adjustIntervals(spread_xs, 1, this.dimensions[\"width\"], 25);\n    }\n\n    private build_grid(): D3Grid {\n        // create a grid config based on the spread elements assinging them to their own columns\n        // keep spacers between each cell\n        let spacer_start = 0;\n        let spacer_end = 0;\n        let elem_idx = 0;\n        this.spread_elements.forEach(interval => {\n            // create spacer unless interval starts at 0\n            spacer_end = interval[0];\n            if (interval[0] !== 0) {\n                const spacer_width = spacer_end - spacer_start;\n                this.gridConfig.columnRatios.push(spacer_width / this.dimensions[\"width\"]);\n                this.gridConfig.rowRatiosPerColumn.push([1]);\n                this.gridConfig.columns += 1;\n                elem_idx += 1;\n            }\n            spacer_start = interval[1];\n            // create element\n            const element_width = interval[1] - interval[0];\n            this.gridConfig.columnRatios.push(element_width / this.dimensions[\"width\"]);\n            this.gridConfig.rowRatiosPerColumn.push([1]);\n            this.gridConfig.columns += 1;\n            this.element_indices.push(elem_idx);\n            elem_idx += 1;\n        });\n        // add final spacer\n        if (spacer_end !== this.dimensions[\"width\"]) {\n            const spacer_width = this.dimensions[\"width\"] - spacer_start;\n            this.gridConfig.columnRatios.push(spacer_width / this.dimensions[\"width\"]);\n            this.gridConfig.rowRatiosPerColumn.push([1]);\n            this.gridConfig.columns += 1;\n        }\n\n        return new D3Grid(this.svg, this.dimensions.height, this.dimensions.width, this.gridConfig);\n    }\n\n    public plot(): void {\n        // create background grid with horizontal lines based on the max value\n        this.yScale = d3.scaleLinear()\n            .domain([0, this.maxValue])\n            .range([this.dimensions.height, 0]);\n        \n        // Add a background rectangle for the grid\n        this.svg.append(\"rect\")\n            .attr(\"class\", \"grid-background\")\n            .attr(\"x\", 0)\n            .attr(\"y\", 0)\n            .attr(\"width\", this.dimensions.width)\n            .attr(\"height\", this.dimensions.height)\n            .attr(\"fill\", \"#f7f7f7\")\n            .attr(\"fill-opacity\", 0.75);\n\n        // Add horizontal grid lines\n        this.svg.append(\"g\")\n            .attr(\"class\", \"grid\")\n            .attr(\"stroke\", \"rgba(0, 0, 0, 0.1)\")\n            .attr(\"stroke-width\", 1)\n            .attr(\"stroke-dasharray\", \"5,5\")\n            .attr(\"opacity\", 0.3)\n            .call(d3.axisLeft(this.yScale)\n                .ticks(5)\n                .tickSize(-this.dimensions.width)\n                .tickFormat(null));\n    }\n\n    public getElementSVG(index: number): d3.Selection<SVGSVGElement, unknown, null, undefined> | undefined {\n        const elem_idx = this.element_indices[index];\n        if (elem_idx === -1) {\n            return undefined;\n        }\n        return this.grid.getCellSvg(elem_idx,0);\n    }\n\n    public getCellDimensions(index: number): { width: number, height: number } | undefined {\n        const elem_idx = this.element_indices[index];\n        if (elem_idx === -1) {\n            return undefined;\n        }\n        return this.grid.getCellDimensions(elem_idx,0);\n    }\n\n    public getCellCoordinates(index: number): { x: number, y: number } | undefined {\n        const elem_idx = this.element_indices[index];\n        if (elem_idx === -1) {\n            return undefined;\n        }\n        return this.grid.getCellCoordinates(elem_idx,0);\n    }\n\n    public getYScale(): d3.ScaleLinear<number, number> {\n        return this.yScale;\n    }\n\n    // compute corresponding x-axis positions for the element\n    public getElementMapping(index: number): [[number,number],[number,number]] {\n        return [this.raw_xs[index],this.spread_elements[index]];\n    }\n}\n\n","import { Dimensions } from '../../types';\n\ninterface TriangleConnectorData {\n    svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    dimensions: Dimensions;\n    points: {\"top\": number, \"left\": number, \"right\": number,\"mid\": number};\n    color: string;\n}\n\n// plots connector triangles from a point to a box\nexport class TriangleConnector {\n    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;\n    private dimensions: any;\n    private points: {\"top\": number, \"left\": number, \"right\": number,\"mid\": number};\n    private color: string = \"#000000\";\n\n    constructor(data: TriangleConnectorData) {\n        this.svg = data.svg;\n        this.dimensions = data.dimensions;\n        this.points = data.points;\n        this.color = data.color;\n    }\n\n    public plot(): void {\n        // draw a triangle from raw_midpoint to spread interval\n        this.svg.append(\"polygon\")\n            .attr(\"points\", `${this.points.top},${0} ${this.points.left},${this.dimensions.height} ${this.points.right},${this.dimensions.height}`)\n            .attr(\"fill\", \"none\")  // No fill for the triangle\n            .attr(\"fill\", this.color)  // Color of the triangle lines\n            .attr(\"fill-opacity\", 0.025)  // Opacity of the triangle\n            .attr(\"stroke\", this.color)  // Color of the triangle lines\n            .attr(\"stroke-opacity\", 0.15)  // Opacity of the triangle\n            .attr(\"stroke-width\", 1);  // Width of the triangle lines\n\n        // Plot the line connecting raw_midpoint to spread_midpoint\n        this.svg.append(\"line\")\n            .attr(\"x1\", this.points.top)\n            .attr(\"y1\", 0)\n            .attr(\"x2\", this.points.mid)\n            .attr(\"y2\", this.dimensions.height)\n            .attr(\"stroke\", this.color)  // Color of the line\n            .attr(\"stroke-width\", 1)  // Width of the line\n            .attr(\"stroke-dasharray\", \"5,5\");\n    }\n}"],"mappings":"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","names":["line","Object","line","line","svg_coordinates","d3","d3"]}